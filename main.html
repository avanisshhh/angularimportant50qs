<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angular Interview Prep</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Basic styling for pre/code blocks */
        pre {
            background-color: #f4f4f8;
            border: 1px solid #ddd;
            border-radius: 0.375rem; /* rounded-md */
            padding: 1rem; /* p-4 */
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        /* Styling for tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }
        th, td {
            border: 1px solid #cbd5e1; /* slate-300 */
            padding: 0.75rem; /* p-3 */
            text-align: left;
        }
        th {
            background-color: #f1f5f9; /* slate-100 */
            font-weight: 600; /* font-semibold */
        }
        /* Chart container styling (as per prompt requirements, even if not used in this specific SPA) */
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* Example max-width */
            margin-left: auto;
            margin-right: auto;
            height: 300px; /* Base height */
            max-height: 400px; /* Max height */
        }
        @media (min-width: 768px) { /* md breakpoint */
            .chart-container {
                height: 350px;
            }
        }
        .active-question {
            background-color: #0ea5e9; /* sky-500 */
            color: white;
        }
        .active-question:hover {
            background-color: #0284c7; /* sky-600 */
        }
        .category-button.active-category {
            background-color: #38bdf8; /* sky-400 */
            color: white;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">
    <!-- Visualization & Content Choices:
        - Question List (Sidebar): Goal: Inform/Navigate. Method: Clickable HTML list. Interaction: Click to select, search filters list. JS for interaction.
        - Categories (Sidebar): Goal: Organize/Navigate. Method: Clickable HTML buttons/links. Interaction: Click to filter question list. JS for interaction.
        - Search Bar (Sidebar): Goal: Filter. Method: HTML input. Interaction: Real-time text filtering. JS for interaction.
        - Q&A Display (Main): Goal: Inform/Explain. Method: HTML headings, paragraphs, pre/code for code, table for tabular data. Interaction: Static display, scrollable. JS to update content.
        - Justification: Standard HTML elements with JS for interactivity provide a lightweight and accessible way to present the Q&A format effectively. No complex charts needed.
        - Libraries: Vanilla JS. Tailwind CSS.
        - CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <div class="flex flex-col md:flex-row min-h-screen">
        <aside id="sidebar" class="w-full md:w-1/3 lg:w-1/4 bg-slate-100 p-4 border-r border-slate-300 overflow-y-auto h-screen md:sticky md:top-0">
            <header class="mb-6">
                <h1 class="text-2xl font-bold text-sky-700">Angular Interview Prep</h1>
                <p class="text-sm text-slate-600">Top 50 Questions</p>
            </header>

            <div class="mb-4">
                <input type="text" id="searchInput" placeholder="ðŸ” Search questions..." class="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-sky-500 focus:border-sky-500 outline-none">
            </div>

            <div class="mb-4">
                <h2 class="text-lg font-semibold mb-2 text-slate-700">Categories</h2>
                <div id="categoryButtons" class="flex flex-wrap gap-2">
                    </div>
            </div>

            <nav>
                <h2 class="text-lg font-semibold mb-2 text-slate-700">Questions</h2>
                <ul id="questionList" class="space-y-1">
                    </ul>
            </nav>
        </aside>

        <main id="mainContent" class="flex-1 p-6 md:p-8 lg:p-10 overflow-y-auto h-screen">
            <div id="welcomeMessage" class="text-center text-slate-500">
                <h2 class="text-3xl font-semibold mb-4">Welcome!</h2>
                <p class="text-lg">Select a question from the sidebar to view its answer.</p>
                <p class="mt-2">Use the search bar or category filters to find specific topics.</p>
            </div>
            <article id="qaDisplay" class="hidden">
                <h2 id="selectedQuestion" class="text-2xl md:text-3xl font-bold text-sky-700 mb-6 border-b-2 border-sky-200 pb-3"></h2>
                <div id="selectedAnswer" class="prose prose-slate max-w-none text-slate-700 leading-relaxed">
                    </div>
            </article>
        </main>
    </div>

    <script>
        const interviewQuestions = [
            {
                id: 1,
                category: "Angular Core Concepts",
                question: "What is the main purpose of Angular?",
                answer: `<p>Angular is a comprehensive, open-source, front-end framework primarily used for building <strong>single-page applications (SPAs)</strong> and complex web applications. Its main purpose is to simplify the development of dynamic, interactive, and high-performance user interfaces by providing a structured and opinionated approach to application architecture, data binding, routing, and component-based development.</p>`
            },
            {
                id: 2,
                category: "Angular Core Concepts",
                question: "What are directives in Angular and how many types of directives exist?",
                answer: `<p>Directives are classes that add behavior to elements in Angular applications. They allow you to manipulate the DOM (Document Object Model) by changing its appearance, structure, or behavior.</p>
                         <p>There are three main types of directives in Angular:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Component Directives:</strong> These are directives with a template. Components are the most common type of directive and are the building blocks of Angular applications.</li>
                            <li><strong>Structural Directives:</strong> These directives change the DOM layout by adding or removing elements. Examples include <code>*ngIf</code>, <code>*ngFor</code>, and <code>*ngSwitch</code>.</li>
                            <li><strong>Attribute Directives:</strong> These directives change the appearance or behavior of an element, component, or another directive. Examples include <code>NgStyle</code>, <code>NgClass</code>, and custom attribute directives.</li>
                         </ol>`
            },
            {
                id: 3,
                category: "Angular Core Concepts",
                question: "Explain data bindings and the different types.",
                answer: `<p>Data binding is a mechanism that synchronizes data between the component's logic (TypeScript code) and the view (HTML template). It ensures that changes in one place are automatically reflected in the other.</p>
                         <p>There are four main types of data binding:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Interpolation (<code>{{ }}</code>):</strong> One-way data binding from component to view. It displays a component property's value in the template. Example: <code>&lt;h1&gt;{{ title }}&lt;/h1&gt;</code></li>
                            <li><strong>Property Binding (<code>[ ]</code>):</strong> One-way data binding from component to view. It binds a component property to an HTML element's property. Example: <code>&lt;img [src]="imageUrl"&gt;</code></li>
                            <li><strong>Event Binding (<code>( )</code>):</strong> One-way data binding from view to component. It listens for events (like clicks, key presses) on HTML elements and executes a method in the component. Example: <code>&lt;button (click)="onClick()"&gt;Click Me&lt;/button&gt;</code></li>
                            <li><strong>Two-Way Data Binding (<code>[( )]</code> - <code>ngModel</code>):</strong> Combines property binding and event binding. It allows data to flow both ways: from component to view and from view to component. Changes in the component update the view, and changes in the view update the component. Example: <code>&lt;input [(ngModel)]="userName"&gt;</code> (Requires <code>FormsModule</code>)</li>
                         </ol>`
            },
            {
                id: 4,
                category: "Angular Core Concepts",
                question: "What are the basic components involved in Angular?",
                answer: `<p>The term "basic components involved in Angular" usually refers to the fundamental building blocks and concepts that make up an Angular application. These include:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Components:</strong> The primary building blocks of Angular applications, responsible for controlling a portion of the screen (view).</li>
                            <li><strong>Modules (<code>NgModule</code>):</strong> Containers for a cohesive block of an application, typically grouping related components, services, directives, and pipes.</li>
                            <li><strong>Templates:</strong> HTML files that define the view for a component.</li>
                            <li><strong>Metadata (Decorators):</strong> Used to configure a class as an Angular component, directive, service, etc., providing Angular with instructions on how to process it.</li>
                            <li><strong>Data Binding:</strong> The mechanism for communication between the component's logic and its template.</li>
                            <li><strong>Services:</strong> Classes used to provide reusable functionality and data to components, promoting separation of concerns.</li>
                            <li><strong>Directives:</strong> Classes that modify the behavior or structure of the DOM.</li>
                            <li><strong>Pipes:</strong> Used to transform data in the template before it is displayed.</li>
                            <li><strong>Routing:</strong> Manages navigation between different views (components) in a single-page application.</li>
                         </ul>`
            },
            {
                id: 5,
                category: "Angular Core Concepts",
                question: "Whatâ€™s the difference between AngularJS and Angular?",
                answer: `<p>AngularJS (often referred to as Angular 1) and Angular (Angular 2+ or simply "Angular") are fundamentally different frameworks, despite sharing a similar name and purpose.</p>
                        <table>
                            <thead>
                                <tr><th>Feature</th><th>AngularJS (Angular 1)</th><th>Angular (Angular 2+)</th></tr>
                            </thead>
                            <tbody>
                                <tr><td><strong>Architecture</strong></td><td>MVC (Model-View-Controller) / MVVM (Model-View-ViewModel)</td><td>Component-based architecture</td></tr>
                                <tr><td><strong>Language</strong></td><td>JavaScript</td><td>TypeScript (primary), JavaScript</td></tr>
                                <tr><td><strong>Mobile</strong></td><td>Not mobile-friendly by design</td><td>Mobile-first approach, better for native apps (Ionic, NativeScript)</td></tr>
                                <tr><td><strong>Performance</strong></td><td>Slower, especially for complex applications</td><td>Faster, better change detection, tree-shaking</td></tr>
                                <tr><td><strong>CLI</strong></td><td>No official CLI</td><td>Official Angular CLI for scaffolding and development</td></tr>
                                <tr><td><strong>Directives</strong></td><td>Broad concept, used for almost everything</td><td>More focused, distinct types (components, structural, attribute)</td></tr>
                                <tr><td><strong>Routing</strong></td><td><code>ngRoute</code> (basic), <code>ui-router</code> (advanced)</td><td><code>@angular/router</code> (powerful and feature-rich)</td></tr>
                                <tr><td><strong>Change Detection</strong></td><td>Dirty checking (watches all scopes)</td><td>Zone.js (detects async operations), faster, more efficient</td></tr>
                                <tr><td><strong>Learning Curve</strong></td><td>Easier to start, harder to master for large apps</td><td>Steeper initial learning curve, easier for large-scale apps</td></tr>
                            </tbody>
                        </table>`
            },
            {
                id: 6,
                category: "Angular Core Concepts",
                question: "What are components and modules in Angular?",
                answer: `<h3>Components:</h3>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Components are the fundamental building blocks of Angular applications.</li>
                            <li>They are essentially directives with a template.</li>
                            <li>Each component controls a specific part of the screen (its "view").</li>
                            <li>A component consists of:
                                <ul class="list-circle list-inside ml-6">
                                    <li>A TypeScript class (containing the component's logic).</li>
                                    <li>An HTML template (defining the component's view).</li>
                                    <li>CSS styles (defining the component's appearance).</li>
                                    <li>A decorator (<code>@Component()</code>) that provides metadata to Angular.</li>
                                </ul>
                            </li>
                            <li>Components are designed to be reusable and encapsulate their own logic and UI.</li>
                         </ul>
                         <h3>Modules (<code>NgModule</code>):</h3>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Modules are containers that group a cohesive block of an application.</li>
                            <li>They help organize the application into functional units.</li>
                            <li>Every Angular application has at least one root module (<code>AppModule</code>), and it can have many feature modules.</li>
                            <li>An <code>NgModule</code> is a class decorated with <code>@NgModule()</code> metadata, which declares:
                                <ul class="list-circle list-inside ml-6">
                                    <li><code>declarations</code>: Components, directives, and pipes that belong to this module.</li>
                                    <li><code>imports</code>: Other modules whose exported classes are needed by component templates in this module.</li>
                                    <li><code>providers</code>: Services that are available for dependency injection within this module.</li>
                                    <li><code>bootstrap</code>: The root component that Angular should launch when it bootstraps the application (only in the root module).</li>
                                    <li><code>exports</code>: A subset of <code>declarations</code> that should be visible and usable in the component templates of other modules that import this one.</li>
                                </ul>
                            </li>
                         </ul>`
            },
            {
                id: 7,
                category: "Angular Core Concepts",
                question: "What are decorators in Angular?",
                answer: `<p>Decorators are special kinds of declarations that can be attached to classes, methods, properties, or parameters. They are functions that add metadata to a class, its members, or function arguments, which Angular then uses to understand how to process that class or member.</p>
                         <p>Decorators are a TypeScript feature that Angular heavily utilizes. They are prefixed with an <code>@</code> symbol.</p>
                         <p>Common Angular decorators include:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><code>@Component()</code>: For classes that are components.</li>
                            <li><code>@Directive()</code>: For classes that are directives.</li>
                            <li><code>@Pipe()</code>: For classes that are pipes.</li>
                            <li><code>@Injectable()</code>: For classes that are services and can be injected.</li>
                            <li><code>@NgModule()</code>: For classes that are Angular modules.</li>
                            <li><code>@Input()</code>: For properties that receive data from a parent component.</li>
                            <li><code>@Output()</code>: For properties that emit events to a parent component.</li>
                            <li><code>@ViewChild()</code>, <code>@ViewChildren()</code>, <code>@ContentChild()</code>, <code>@ContentChildren()</code>: For querying elements in the view or content.</li>
                         </ul>`
            },
            {
                id: 8,
                category: "Angular Core Concepts",
                question: "What is metadata or annotations in Angular?",
                answer: `<p>In Angular, <strong>metadata</strong> (often referred to as <strong>annotations</strong> in older contexts or other frameworks) is data that configures a class, property, method, or parameter. It tells Angular how to treat a class and its members.</p>
                         <p>Metadata is attached using <strong>decorators</strong> (e.g., <code>@Component</code>, <code>@Injectable</code>, <code>@Input</code>). When Angular processes your code, it reads this metadata to understand:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Which classes are components, directives, pipes, or services.</li>
                            <li>How components should be rendered (their template, styles, selector).</li>
                            <li>Which dependencies should be injected into a class.</li>
                            <li>How data should flow between components.</li>
                         </ul>
                         <p>For example, the <code>@Component</code> decorator's metadata specifies the <code>selector</code>, <code>templateUrl</code>, and <code>styleUrls</code> for a component:</p>
                         <pre><code>@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css']\n})\nexport class MyComponent { /* ... */ }</code></pre>
                         <p>This metadata is crucial for Angular's compiler to understand and build the application correctly.</p>`
            },
            {
                id: 9,
                category: "Angular Core Concepts",
                question: "What are templates in Angular?",
                answer: `<p>In Angular, a <strong>template</strong> is an HTML snippet that defines the view for a component. It's the part of the component that Angular renders to the DOM. Templates combine standard HTML with Angular's template syntax, which allows you to:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Display component data:</strong> Using interpolation (<code>{{ }}</code>) and property binding (<code>[ ]</code>).</li>
                            <li><strong>Handle user input:</strong> Using event binding (<code>( )</code>).</li>
                            <li><strong>Apply structural directives:</strong> To add, remove, or manipulate DOM elements (<code>*ngIf</code>, <code>*ngFor</code>).</li>
                            <li><strong>Apply attribute directives:</strong> To change the appearance or behavior of elements (<code>[ngClass]</code>, <code>[ngStyle]</code>).</li>
                            <li><strong>Use pipes:</strong> To transform data before displaying it (<code>{{ date | date:'shortDate' }}</code>).</li>
                            <li><strong>Include other components:</strong> By using their selectors.</li>
                         </ul>
                         <p>Templates can be defined either inline within the <code>@Component</code> decorator's <code>template</code> property (as a string) or in a separate HTML file referenced by <code>templateUrl</code>.</p>`
            },
            {
                id: 10,
                category: "Angular Core Concepts",
                question: "What is SPA and how do you implement it in Angular?",
                answer: `<h3>SPA (Single-Page Application):</h3>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>A single-page application is a web application that loads a single HTML page and dynamically updates that page as the user interacts with the application.</li>
                            <li>Instead of loading entirely new pages from the server for every user action, SPAs rewrite the current page with new data from the server.</li>
                            <li>This provides a more fluid, desktop-like user experience, as it avoids full page reloads.</li>
                         </ul>
                         <h3>How to implement it in Angular:</h3>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Angular is inherently designed for building SPAs, primarily through its <strong>Router module (<code>@angular/router</code>)</strong>.</li>
                            <li><strong>Steps:</strong>
                                <ol class="list-decimal list-inside ml-6">
                                    <li><strong>Define Routes:</strong> In your <code>AppRoutingModule</code> (or feature routing modules), you define an array of <code>Route</code> objects. Each <code>Route</code> maps a URL path to a component.
                                        <pre><code>import { Routes, RouterModule } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n  { path: '**', redirectTo: '' } // Wildcard route\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }</code></pre>
                                    </li>
                                    <li><strong><code>RouterModule.forRoot(routes)</code>:</strong> This method configures the root router with the defined routes.</li>
                                    <li><strong><code>router-outlet</code>:</strong> You place the <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code> directive in your main application component's template (<code>app.component.html</code>). This is where Angular dynamically loads the component associated with the current route.
                                        <pre><code>&lt;nav&gt;\n  &lt;a routerLink="/"&gt;Home&lt;/a&gt;\n  &lt;a routerLink="/about"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></pre>
                                    </li>
                                    <li><strong><code>routerLink</code>:</strong> Use the <code>routerLink</code> directive on anchor tags (<code>&lt;a&gt;</code>) to create navigation links.</li>
                                    <li><strong><code>Router</code> Service:</strong> You can also programmatically navigate using the <code>Router</code> service injected into your components.
                                        <pre><code>import { Router } from '@angular/router';\n// ...\nconstructor(private router: Router) {}\ngotoAbout() {\n  this.router.navigate(['/about']);\n}</code></pre>
                                    </li>
                                </ol>
                            </li>
                         </ul>`
            },
            {
                id: 11,
                category: "Angular Core Concepts",
                question: "Explain the importance of routing in Angular & how to implement it.",
                answer: `<h3>Importance of Routing:</h3>
                        <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Single-Page Application (SPA) Navigation:</strong> Fundamental for SPAs, allowing navigation between views without full page reloads.</li>
                            <li><strong>Deep Linking:</strong> Enables bookmarking and sharing direct links to specific views.</li>
                            <li><strong>Modularization:</strong> Helps organize the application into distinct, navigable sections.</li>
                            <li><strong>Lazy Loading:</strong> Crucial for loading parts of the application on demand.</li>
                            <li><strong>State Management:</strong> Can carry state (parameters) between views.</li>
                            <li><strong>Authentication/Authorization Guards:</strong> Protects routes based on user permissions.</li>
                        </ul>
                        <h3>How to Implement It:</h3>
                        <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Import <code>RouterModule</code>:</strong> In <code>AppModule</code> or feature module.
                                <pre><code>import { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n  { path: 'products/:id', component: ProductDetailComponent },\n  { path: '**', redirectTo: '' }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  // ...\n})\nexport class AppModule { }</code></pre>
                            </li>
                            <li><strong><code>router-outlet</code>:</strong> Place <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code> in your main component's template.</li>
                            <li><strong><code>routerLink</code>:</strong> Use on HTML elements for navigation links.
                                <ul class="list-circle list-inside ml-6">
                                    <li><code>routerLink="/path"</code></li>
                                    <li><code>[routerLink]="['/path', paramValue]"</code></li>
                                </ul>
                            </li>
                            <li><strong><code>Router</code> Service (Programmatic Navigation):</strong> Inject <code>Router</code> service.
                                <pre><code>constructor(private router: Router) {}\nnavigateToProduct(id: string) {\n  this.router.navigate(['/products', id]);\n}</code></pre>
                            </li>
                            <li><strong><code>ActivatedRoute</code> Service (Accessing Route Parameters):</strong> Inject <code>ActivatedRoute</code>.
                                <pre><code>constructor(private route: ActivatedRoute) {}\nngOnInit() {\n  this.route.paramMap.subscribe(params => {\n    this.productId = params.get('id');\n  });\n}</code></pre>
                            </li>
                        </ol>`
            },
            {
                id: 12,
                category: "Angular Core Concepts",
                question: "What is lazy loading in Angular?",
                answer: `<p>Lazy loading is a technique in Angular that allows you to load parts of your application <strong>on demand</strong> rather than loading everything upfront when the application starts. Instead of bundling all modules into a single large bundle, lazy loading creates separate bundles for different feature modules. These bundles are then loaded only when the user navigates to a route that requires them.</p>
                         <p><strong>Benefits:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Faster Initial Load Times:</strong> The initial bundle size is significantly reduced, leading to quicker application startup.</li>
                            <li><strong>Improved Performance:</strong> Resources are only loaded when needed, conserving bandwidth and memory.</li>
                            <li><strong>Better User Experience:</strong> Users can start interacting with the main part of the application sooner.</li>
                         </ul>`
            },
            {
                id: 13,
                category: "Angular Core Concepts",
                question: "How do you implement lazy loading in Angular?",
                answer: `<p>Lazy loading is implemented using Angular's router.</p>
                         <p><strong>Steps:</strong></p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Create a Feature Module:</strong> Ensure the part of your application you want to lazy load is encapsulated within its own <code>NgModule</code>. (e.g., <code>ng generate module products --route products --module app.module</code>)</li>
                            <li><strong>Define Lazy Route in <code>AppRoutingModule</code>:</strong> Use the <code>loadChildren</code> property.
                                <pre><code>// app-routing.module.ts\nconst routes: Routes = [\n  { path: 'home', component: HomeComponent },\n  {\n    path: 'products', // This path will trigger lazy loading\n    loadChildren: () => import('./products/products.module').then(m => m.ProductsModule)\n  }\n];</code></pre>
                            </li>
                            <li><strong>Define Child Routes in the Feature Module's Routing Module:</strong> Use <code>RouterModule.forChild(routes)</code>.
                                <pre><code>// products/products-routing.module.ts\nconst routes: Routes = [\n  { path: '', component: ProductListComponent },\n  { path: ':id', component: ProductDetailComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class ProductsRoutingModule { }</code></pre>
                            </li>
                            <li><strong>Import Routing Module into Feature Module:</strong>
                                <pre><code>// products/products.module.ts\n@NgModule({\n  declarations: [/*...*/],\n  imports: [\n    CommonModule,\n    ProductsRoutingModule // Add to imports\n  ]\n})\nexport class ProductsModule { }</code></pre>
                            </li>
                         </ol>
                         <p>When a user navigates to <code>/products</code>, Angular will asynchronously load the <code>products.module.ts</code> bundle and then activate the appropriate component within it.</p>`
            },
            {
                id: 14,
                category: "Node.js & NPM",
                question: "What is Node.js?",
                answer: `<p>Node.js is an <strong>open-source, cross-platform JavaScript runtime environment</strong> that allows developers to execute JavaScript code outside of a web browser. It's built on Chrome's V8 JavaScript engine.</p>
                         <p><strong>Key characteristics:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Server-side JavaScript:</strong> Enables JavaScript to be used for back-end development, full-stack development, and command-line tools.</li>
                            <li><strong>Asynchronous and Event-Driven:</strong> Uses a non-blocking I/O model, making it highly efficient and scalable for handling many concurrent connections (e.g., real-time applications, APIs).</li>
                            <li><strong>Single-Threaded (Event Loop):</strong> Although it's single-threaded, its event-driven nature allows it to handle concurrent operations without creating multiple threads for each request.</li>
                            <li><strong>NPM (Node Package Manager):</strong> Comes with NPM, the world's largest ecosystem of open-source libraries.</li>
                         </ul>`
            },
            {
                id: 15,
                category: "Node.js & NPM",
                question: "What is NPM?",
                answer: `<p>NPM stands for <strong>Node Package Manager</strong>. It is the default package manager for Node.js and the world's largest software registry.</p>
                         <p><strong>NPM serves two main purposes:</strong></p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Command-line utility:</strong> It's a command-line tool (<code>npm</code>) that allows you to install, manage, and publish Node.js packages (libraries and modules).</li>
                            <li><strong>Online registry:</strong> It's an online database (npmjs.com) of public and private packages that developers can use in their projects.</li>
                         </ol>
                         <p>Developers use NPM to:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Install project dependencies (e.g., <code>npm install express</code>).</li>
                            <li>Manage project scripts (defined in <code>package.json</code>).</li>
                            <li>Publish their own packages.</li>
                            <li>Run various development tasks.</li>
                         </ul>`
            },
            {
                id: 16,
                category: "Node.js & NPM",
                question: "Why is the node_modules folder important?",
                answer: `<p>The <code>node_modules</code> folder is crucial because it's where NPM stores <strong>all the dependencies (packages/libraries) that your project needs to run</strong>.</p>
                         <p>When you run <code>npm install</code> (or <code>yarn install</code>), NPM reads your <code>package.json</code> file, downloads all the specified packages and their own dependencies, and places them into the <code>node_modules</code> folder within your project directory.</p>
                         <p><strong>Importance:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Project Isolation:</strong> Each project gets its own <code>node_modules</code> folder, ensuring that different projects can use different versions of the same library without conflicts.</li>
                            <li><strong>Dependency Resolution:</strong> NPM handles the complex task of resolving and installing all nested dependencies of your project.</li>
                            <li><strong>Local Development:</strong> Your application's code relies on the modules in this folder to function during development and when running locally.</li>
                            <li><strong>Build Process:</strong> Build tools (like Angular CLI, Webpack) use the modules in <code>node_modules</code> to bundle your application for deployment.</li>
                         </ul>
                         <p><strong>Note:</strong> You typically <strong>do not commit</strong> the <code>node_modules</code> folder to version control (like Git) because it can be very large. Instead, <code>package.json</code> (which lists dependencies) is committed, and other developers can recreate the <code>node_modules</code> folder by running <code>npm install</code>.</p>`
            },
            {
                id: 17,
                category: "Node.js & NPM",
                question: "What is package.json?",
                answer: `<p><code>package.json</code> is a <strong>manifest file</strong> in Node.js and NPM projects that contains metadata about the project and defines its dependencies. It's a central configuration file for any JavaScript/TypeScript project managed by NPM (or Yarn).</p>
                         <p><strong>Key information stored in <code>package.json</code>:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>name</code></strong>: The name of the project.</li>
                            <li><strong><code>version</code></strong>: The current version of the project.</li>
                            <li><strong><code>description</code></strong>: A brief description of the project.</li>
                            <li><strong><code>main</code></strong>: The entry point of the application (e.g., <code>index.js</code>).</li>
                            <li><strong><code>scripts</code></strong>: Custom scripts that can be run using <code>npm run &lt;script-name&gt;</code> (e.g., <code>start</code>, <code>build</code>, <code>test</code>).</li>
                            <li><strong><code>dependencies</code></strong>: A list of production dependencies (libraries required for the application to run in production).</li>
                            <li><strong><code>devDependencies</code></strong>: A list of development dependencies (libraries required only during development, like testing frameworks, build tools).</li>
                            <li><strong><code>author</code></strong>, <strong><code>license</code></strong>, etc.</li>
                         </ul>
                         <p>When you run <code>npm install</code>, NPM reads this file to determine which packages to download and install into <code>node_modules</code>.</p>`
            },
            {
                id: 18,
                category: "Angular Core Concepts",
                question: "What is TypeScript?",
                answer: `<p>TypeScript is an <strong>open-source programming language developed by Microsoft</strong> that is a <strong>superset of JavaScript</strong>. This means that all valid JavaScript code is also valid TypeScript code, but TypeScript adds optional static typing and other features.</p>
                         <p><strong>Key features and benefits:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Static Typing:</strong> Allows you to define types for variables, function parameters, and return values. This helps catch type-related errors during development (compile time) rather than at runtime.</li>
                            <li><strong>Enhanced Tooling:</strong> Provides better IDE support (autocompletion, refactoring, error checking) due to type information.</li>
                            <li><strong>Improved Readability and Maintainability:</strong> Types make code easier to understand and maintain, especially in large codebases.</li>
                            <li><strong>ES6+ Features:</strong> Supports modern JavaScript features (ES6, ES7, etc.) and transpiles them down to older JavaScript versions for broader browser compatibility.</li>
                            <li><strong>Object-Oriented Features:</strong> Adds classes, interfaces, enums, and access modifiers (public, private, protected) that are common in traditional OOP languages.</li>
                         </ul>
                         <p>Angular is built entirely with TypeScript, and it's the recommended language for Angular development.</p>`
            },
            {
                id: 19,
                category: "Angular Core Concepts",
                question: "What is the need for Angular CLI?",
                answer: `<p>Angular CLI (Command Line Interface) is a powerful tool used to <strong>initialize, develop, scaffold, and maintain Angular applications</strong> directly from a command shell.</p>
                         <p><strong>Need for Angular CLI:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Rapid Project Setup:</strong> Quickly creates a new Angular project with a standard structure and configuration (<code>ng new</code>).</li>
                            <li><strong>Code Generation (Scaffolding):</strong> Generates components, services, modules, directives, pipes, etc., with boilerplate code, saving time and ensuring consistency (<code>ng generate component</code>, <code>ng g s</code>).</li>
                            <li><strong>Development Server:</strong> Provides a local development server with live reloading, which automatically reloads the browser when changes are made to the code (<code>ng serve</code>).</li>
                            <li><strong>Build Optimization:</strong> Bundles, minifies, and optimizes the application for production deployment (<code>ng build</code>).</li>
                            <li><strong>Testing Tools:</strong> Integrates with testing frameworks (Karma, Protractor) and provides commands to run tests (<code>ng test</code>, <code>ng e2e</code>).</li>
                            <li><strong>Updates:</strong> Helps update Angular and its dependencies to newer versions (<code>ng update</code>).</li>
                            <li><strong>Standardization:</strong> Enforces best practices and a consistent project structure across different Angular projects.</li>
                         </ul>
                         <p>In essence, Angular CLI streamlines the entire development workflow, making it much easier and faster to build Angular applications.</p>`
            },
            {
                id: 20,
                category: "Angular Core Concepts",
                question: "What are services in Angular?",
                answer: `<p>In Angular, a <strong>service</strong> is a plain TypeScript class that is designed to provide reusable functionality, data, or logic to components. Services are typically used for tasks that don't directly involve the UI, such as:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>Fetching data from a server (HTTP requests).</li>
                            <li>Sharing data between components.</li>
                            <li>Logging.</li>
                            <li>Validation logic.</li>
                            <li>Authentication/Authorization logic.</li>
                            <li>Utility functions.</li>
                         </ul>
                         <p><strong>Key characteristics of services:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>@Injectable()</code> Decorator:</strong> Services are typically decorated with <code>@Injectable()</code> to make them eligible for dependency injection.</li>
                            <li><strong>Singletons (by default):</strong> When provided at the root level (<code>{ providedIn: 'root' }</code>), a service is a singleton, meaning only one instance is created and shared across the entire application. This is ideal for shared data or global functionality.</li>
                            <li><strong>Separation of Concerns:</strong> Services help keep components lean and focused on their UI responsibilities, delegating business logic and data handling to services.</li>
                            <li><strong>Dependency Injection:</strong> Components (or other services) don't create instances of services directly; instead, they declare them as dependencies in their constructor, and Angular's dependency injection system provides the instance.</li>
                         </ul>
                         <p><strong>Example:</strong></p>
                         <pre><code>// data.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  constructor(private http: HttpClient) { }\n\n  getUsers(): Observable&lt;any[]&gt; {\n    return this.http.get&lt;any[]&gt;('/api/users');\n  }\n}\n\n// user-list.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from '../data.service';\n\n@Component({ /* ... */ })\nexport class UserListComponent implements OnInit {\n  users: any[] = [];\n\n  constructor(private dataService: DataService) { } // Inject the service\n\n  ngOnInit(): void {\n    this.dataService.getUsers().subscribe(data => {\n      this.users = data;\n    });\n  }\n}</code></pre>`
            },
            {
                id: 21,
                category: "Content & View Manipulation",
                question: "When would you use content projection?",
                answer: `<p>You would use <strong>content projection</strong> (also known as <code>ng-content</code>) in Angular when you want to create a <strong>reusable component</strong> that acts as a container or wrapper for content provided by its parent component. It's a way to "project" or "transclude" content from the parent's template into a specific location within the child component's template.</p>
                         <p><strong>Common use cases:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Wrapper Components:</strong> Creating generic UI components like cards, panels, modals, or layout containers where the inner content is dynamic and determined by the parent.</li>
                            <li><strong>Layout Components:</strong> Defining a common structure (e.g., header, sidebar, main content area) and allowing parent components to fill in the specific content for each area.</li>
                            <li><strong>Custom Form Controls:</strong> Building complex form elements where the input fields themselves are provided by the parent.</li>
                            <li><strong>Component Composition:</strong> Allowing for greater flexibility and reusability by separating the component's structure from its content.</li>
                         </ul>
                         <p><strong>Example:</strong> A <code>CardComponent</code> that provides styling and layout, but the title, image, and body are provided by the parent.</p>
                         <pre><code>&lt;!-- card.component.html --&gt;\n&lt;div class="card"&gt;\n  &lt;div class="card-header"&gt;\n    &lt;ng-content select="[card-title]"&gt;&lt;/ng-content&gt;\n  &lt;/div&gt;\n  &lt;div class="card-body"&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt; &lt;!-- Default slot --&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;!-- parent.component.html --&gt;\n&lt;app-card&gt;\n  &lt;h3 card-title&gt;My Product&lt;/h3&gt;\n  &lt;p&gt;Product description here.&lt;/p&gt;\n&lt;/app-card&gt;</code></pre>`
            },
            {
                id: 22,
                category: "Content & View Manipulation",
                question: "Explain content projection slots in Angular.",
                answer: `<p>Content projection slots in Angular are placeholders within a component's template where content from the parent component is inserted. These placeholders are defined using the <code>&lt;ng-content&gt;</code> element.</p>
                         <p>There are two main types of content projection slots:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Single Slot (Unnamed Slot):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>This is the simplest type. If you have only one <code>&lt;ng-content&gt;</code> tag without a <code>select</code> attribute, it acts as a default slot.</li>
                                    <li>All content projected from the parent that doesn't match another named slot will be placed here.</li>
                                    <li>Example: <code>&lt;ng-content&gt;&lt;/ng-content&gt;</code></li>
                                </ul>
                            </li>
                            <li><strong>Named Slots (Multiple Slots):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>You can create multiple slots by adding a <code>select</code> attribute to <code>&lt;ng-content&gt;</code>. The <code>select</code> attribute takes a CSS selector (e.g., element name, attribute name, class name).</li>
                                    <li>Only content from the parent that matches the specified selector will be projected into that slot.</li>
                                    <li>Example: <code>&lt;ng-content select=".header"&gt;&lt;/ng-content&gt;</code> or <code>&lt;ng-content select="[footer-actions]"&gt;&lt;/ng-content&gt;</code></li>
                                </ul>
                            </li>
                         </ol>
                         <p><strong>How it works:</strong> When Angular renders a component using content projection, it takes the content provided by the parent (between the child component's tags) and places it into the corresponding <code>&lt;ng-content&gt;</code> slots in the child's template based on the <code>select</code> attribute or the default slot.</p>`
            },
            {
                id: 23,
                category: "Content & View Manipulation",
                question: "Why do we need ViewChild and ViewChildren in Angular?",
                answer: `<p>We need <code>ViewChild</code> and <code>ViewChildren</code> in Angular to <strong>query and get references to elements or directives/components from the component's own template (its view)</strong>. They allow a component's class to interact with elements rendered in its HTML template after the view has been initialized.</p>
                         <p><strong>Why they are needed:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Direct DOM Manipulation (Rarely Recommended):</strong> Can be used to get a reference to a native HTML element (<code>ElementRef</code>) for low-level DOM operations (e.g., focusing an input).</li>
                            <li><strong>Interacting with Child Components/Directives:</strong> The primary use case is to get an instance of a child component or directive within the current component's view. This allows the parent to call methods on the child or access its properties.</li>
                            <li><strong>Accessing Template Reference Variables:</strong> To get a reference to an element with a template reference variable (<code>#myElement</code>).</li>
                            <li><strong>Dynamic Content (e.g., forms):</strong> Useful for accessing form controls or other dynamic elements.</li>
                            <li><strong>Managing Multiple Instances:</strong> <code>ViewChildren</code> is used when you need to interact with multiple instances of the same component or directive.</li>
                         </ul>
                         <p><strong>When to use which:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>@ViewChild()</code>:</strong> Gets a <strong>single</strong> reference to the *first* matching element or directive/component.</li>
                            <li><strong><code>@ViewChildren()</code>:</strong> Gets a <strong>QueryList</strong> (a collection) of references to *all* matching elements or directives/components.</li>
                         </ul>
                         <p><strong>Important Lifecycle Hook:</strong> References are available only after the <code>ngAfterViewInit</code> lifecycle hook.</p>`
            },
            {
                id: 24,
                category: "Content & View Manipulation",
                question: "What is a template reference variable?",
                answer: `<p>A <strong>template reference variable</strong> is a special kind of variable that you can declare in an Angular template to get a direct reference to a DOM element, a component instance, a directive instance, or an <code>NgTemplateOutlet</code> instance.</p>
                         <p>It's essentially a way to "name" an element in your template so you can refer to it from other parts of the template or from the component's TypeScript code (using <code>@ViewChild</code>).</p>
                         <p><strong>Syntax:</strong> A template reference variable is declared by prefixing a variable name with a hash symbol (<code>#</code>).</p>
                         <p><strong>Example:</strong></p>
                         <pre><code>&lt;input #myInput type="text" placeholder="Enter text"&gt;\n&lt;button (click)="myInput.focus()"&gt;Focus Input&lt;/button&gt;\n\n&lt;app-child-component #childComp&gt;&lt;/app-child-component&gt;\n&lt;button (click)="childComp.sayHello()"&gt;Call Child Method&lt;/button&gt;</code></pre>
                         <p><strong>What it can reference:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>HTML element: <code>&lt;h1 #myHeading&gt;&lt;/h1&gt;</code></li>
                            <li>Component instance: <code>&lt;app-child #childInstance&gt;&lt;/app-child&gt;</code></li>
                            <li>Directive instance: <code>&lt;form #myForm="ngForm"&gt;&lt;/form&gt;</code></li>
                            <li><code>ng-template</code>: <code>&lt;ng-template #myTemplate&gt;...&lt;/ng-template&gt;</code></li>
                         </ul>`
            },
            {
                id: 25,
                category: "Content & View Manipulation",
                question: "Explain ContentChild and ContentChildren.",
                answer: `<p><code>ContentChild</code> and <code>ContentChildren</code> are Angular decorators used to query and get references to elements or directives/components that are <strong>projected into</strong> a component's view via content projection (<code>&lt;ng-content&gt;</code>).</p>
                         <p>They are similar to <code>ViewChild</code> and <code>ViewChildren</code>, but they operate on content that comes from the <em>parent</em> component's template and is "projected" into the <em>child</em> component's slot, rather than elements defined directly within the child component's own template.</p>
                         <p><strong>When they are needed:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>When a component acts as a wrapper or container and needs to interact with the dynamic content passed into it by its parent.</li>
                            <li>For example, a custom tab component might need to query for all <code>TabPanelComponent</code> instances projected into it.</li>
                         </ul>
                         <p><strong>When to use which:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>@ContentChild()</code>:</strong> Used to get a <strong>single</strong> reference to the *first* matching projected element or directive/component.</li>
                            <li><strong><code>@ContentChildren()</code>:</strong> Used to get a <strong>QueryList</strong> (a collection) of references to *all* matching projected elements or directives/components.</li>
                         </ul>
                         <p><strong>Important Lifecycle Hook:</strong> References are available only after the <code>ngAfterContentInit</code> lifecycle hook.</p>
                         <p><strong>Example:</strong></p>
                         <pre><code>&lt;!-- parent.component.html --&gt;\n&lt;app-tab-container&gt;\n  &lt;app-tab-panel title="Tab 1"&gt;Content for tab 1&lt;/app-tab-panel&gt;\n  &lt;app-tab-panel title="Tab 2"&gt;Content for tab 2&lt;/app-tab-panel&gt;\n&lt;/app-tab-container&gt;\n\n&lt;!-- tab-container.component.ts --&gt;\nimport { Component, ContentChildren, QueryList, AfterContentInit } from '@angular/core';\nimport { TabPanelComponent } from '../tab-panel/tab-panel.component';\n\n@Component({ /* ... */ })\nexport class TabContainerComponent implements AfterContentInit {\n  @ContentChildren(TabPanelComponent) tabPanels!: QueryList&lt;TabPanelComponent&gt;;\n\n  ngAfterContentInit() {\n    this.tabPanels.forEach(panel => console.log(panel.title));\n  }\n}</code></pre>`
            },
            {
                id: 26,
                category: "Content & View Manipulation",
                question: "Differentiate between ViewChild, ViewChildren, ContentChild, and ContentChildren.",
                answer: `<table>
                            <thead>
                                <tr><th>Feature</th><th>@ViewChild() / @ViewChildren()</th><th>@ContentChild() / @ContentChildren()</th></tr>
                            </thead>
                            <tbody>
                                <tr><td><strong>Source of Query</strong></td><td>Queries elements/components/directives in the <strong>component's own template (view)</strong>.</td><td>Queries elements/components/directives that are <strong>projected into</strong> the component's view via <code>&lt;ng-content&gt;</code>.</td></tr>
                                <tr><td><strong>Relationship</strong></td><td>Child elements defined directly within the component's HTML.</td><td>Child elements provided by the <em>parent</em> component and placed into the child's content projection slot.</td></tr>
                                <tr><td><strong>Purpose</strong></td><td>Parent component needs to interact with its direct children/elements.</td><td>Child component (wrapper/container) needs to interact with content <em>passed into it</em>.</td></tr>
                                <tr><td><strong>Availability</strong></td><td>Available after <code>ngAfterViewInit</code> lifecycle hook.</td><td>Available after <code>ngAfterContentInit</code> lifecycle hook.</td></tr>
                                <tr><td><strong>Single/Multiple</strong></td><td><code>ViewChild</code> for single, <code>ViewChildren</code> for multiple (QueryList).</td><td><code>ContentChild</code> for single, <code>ContentChildren</code> for multiple (QueryList).</td></tr>
                            </tbody>
                         </table>
                         <p><strong>Analogy:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>ViewChild/ViewChildren</code>:</strong> A parent looking at children *they themselves created* (elements in their template).</li>
                            <li><strong><code>ContentChild/ContentChildren</code>:</strong> A parent looking at children *brought to them by someone else* (content projected from another component).</li>
                         </ul>`
            },
            {
                id: 27,
                category: "Content & View Manipulation",
                question: "What is { static: true } in ViewChild?",
                answer: `<p>The <code>{ static: true }</code> option in <code>@ViewChild()</code> (and <code>@ContentChild()</code>) determines <strong>when the query result should be resolved</strong>.</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>{ static: false }</code> (Default):</strong>
                                <ul class="list-circle list-inside ml-6">
                                    <li>The query result is resolved <strong>after change detection has run</strong> and the element is available in the DOM.</li>
                                    <li>Use when the element is inside a structural directive (<code>*ngIf</code>, <code>*ngFor</code>) or dynamically added.</li>
                                    <li>Reference available in <code>ngAfterViewInit</code> (for <code>ViewChild</code>) or <code>ngAfterContentInit</code> (for <code>ContentChild</code>).</li>
                                </ul>
                            </li>
                            <li><strong><code>{ static: true }</code>:</strong>
                                <ul class="list-circle list-inside ml-6">
                                    <li>The query result is resolved <strong>at the earliest possible time</strong>, during the first change detection cycle, even before <code>ngOnInit</code>.</li>
                                    <li>Use when the element is **always present in the DOM** (not inside dynamic content).</li>
                                    <li>Reference available in <code>ngOnInit</code> (for <code>ViewChild</code>) or <code>ngAfterContentInit</code> (for <code>ContentChild</code>).</li>
                                </ul>
                            </li>
                         </ul>
                         <p><strong>When to use <code>{ static: true }</code>:</strong> When you need to access the element in <code>ngOnInit</code> and it's a static part of the template.</p>
                         <p><strong>When to use <code>{ static: false }</code>:</strong> For elements within structural directives or when access is only needed after full view initialization.</p>`
            },
            {
                id: 28,
                category: "Lifecycle Hooks",
                question: "What is the importance of Angular component hooks/life cycles?",
                answer: `<p>Angular component lifecycle hooks are methods that Angular calls at specific points in a component's lifecycle, from its creation to its destruction. They are crucial for performing actions at the appropriate time.</p>
                         <p><strong>Importance:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Controlled Initialization:</strong> Perform tasks (e.g., fetching data) after inputs are available.</li>
                            <li><strong>Resource Management:</strong> Clean up resources (e.g., unsubscribe from observables) when a component is destroyed, preventing memory leaks.</li>
                            <li><strong>Responding to Changes:</strong> React to changes in input properties or projected content.</li>
                            <li><strong>Interacting with the DOM/View:</strong> Perform operations requiring the view or projected content to be fully initialized.</li>
                            <li><strong>Debugging and Monitoring:</strong> Provides clear points to log or monitor component behavior.</li>
                            <li><strong>Predictable Behavior:</strong> Ensures logic runs only when the component is in a specific state.</li>
                         </ul>`
            },
            {
                id: 29,
                category: "Lifecycle Hooks",
                question: "Explain Angular life cycle hooks in detail.",
                answer: `<p>Angular components have a lifecycle managed by Angular, with hooks to tap into key moments:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong><code>ngOnChanges()</code>:</strong> Called before <code>ngOnInit</code> and whenever data-bound input properties (<code>@Input()</code>) change. Receives a <code>SimpleChanges</code> object. Use to respond to input changes.</li>
                            <li><strong><code>ngOnInit()</code>:</strong> Called once after the first <code>ngOnChanges()</code>. Use for initialization logic that relies on inputs being set (e.g., initial data fetching).</li>
                            <li><strong><code>ngDoCheck()</code>:</strong> Called after <code>ngOnChanges()</code> and <code>ngOnInit()</code>, and on every change detection run. Use for custom change detection (use with caution due to performance).</li>
                            <li><strong><code>ngAfterContentInit()</code>:</strong> Called once after external content (via <code>&lt;ng-content&gt;</code>) is projected into the component. Use to access projected content with <code>@ContentChild()</code> or <code>@ContentChildren()</code>.</li>
                            <li><strong><code>ngAfterContentChecked()</code>:</strong> Called after <code>ngAfterContentInit()</code> and every subsequent <code>ngDoCheck()</code>. Responds after projected content is checked.</li>
                            <li><strong><code>ngAfterViewInit()</code>:</strong> Called once after the component's view and child views are initialized. Use to access the component's own template elements with <code>@ViewChild()</code> or <code>@ViewChildren()</code>.</li>
                            <li><strong><code>ngAfterViewChecked()</code>:</strong> Called after <code>ngAfterViewInit()</code> and every subsequent <code>ngDoCheck()</code>. Responds after the component's view is checked.</li>
                            <li><strong><code>ngOnDestroy()</code>:</strong> Called just before Angular destroys the component. Use for cleanup (e.g., unsubscribing from observables, detaching event handlers) to prevent memory leaks.</li>
                         </ol>`
            },
            {
                id: 30,
                category: "Lifecycle Hooks",
                question: "Differentiate between constructor and ngOnInit().",
                answer: `<table>
                            <thead>
                                <tr><th>Feature</th><th><code>constructor()</code></th><th><code>ngOnInit()</code></th></tr>
                            </thead>
                            <tbody>
                                <tr><td><strong>Purpose</strong></td><td>Standard TypeScript class constructor. Used for <strong>dependency injection</strong> and basic variable initialization.</td><td>Angular-specific lifecycle hook. Used for <strong>initialization logic</strong> that relies on Angular's data-bound inputs (<code>@Input()</code>) being available.</td></tr>
                                <tr><td><strong>When Called</strong></td><td>First method called when an instance of the class is created.</td><td>Called once, after the constructor, and after Angular has initialized all data-bound input properties.</td></tr>
                                <tr><td><strong>Access to Inputs</strong></td><td><code>this.inputProperty</code> will be <code>undefined</code> as inputs are not yet bound.</td><td><code>this.inputProperty</code> will have its bound value.</td></tr>
                                <tr><td><strong>Dependency Injection</strong></td><td>Primary place for injecting services.</td><td>Can also access injected services, but they are already available from the constructor.</td></tr>
                                <tr><td><strong>Use Case</strong></td><td>Injecting services, assigning initial values to local variables.</td><td>Fetching initial data, setting up subscriptions, complex initialization logic that depends on inputs.</td></tr>
                            </tbody>
                         </table>
                         <p><strong>Rule of Thumb:</strong> Use the <code>constructor</code> for dependency injection. Use <code>ngOnInit()</code> for all other initialization logic, especially if it relies on input properties.</p>`
            },
            {
                id: 31,
                category: "HTTP & Services",
                question: "How do you implement HTTP in Angular?",
                answer: `<p>HTTP communication in Angular is primarily implemented using the <strong><code>HttpClient</code> module</strong> (<code>@angular/common/http</code>).</p>
                         <p><strong>Steps:</strong></p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Import <code>HttpClientModule</code>:</strong> In your root <code>AppModule</code> (or a feature module).
                                <pre><code>// app.module.ts\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    HttpClientModule // Add here\n  ],\n  // ...\n})\nexport class AppModule { }</code></pre>
                            </li>
                            <li><strong>Inject <code>HttpClient</code> into a Service:</strong> Encapsulate HTTP logic in services.
                                <pre><code>// data.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  private apiUrl = 'https://api.example.com';\n\n  constructor(private http: HttpClient) { } // Inject HttpClient\n\n  getData(): Observable&lt;any[]&gt; {\n    return this.http.get&lt;any[]&gt;(\`\${this.apiUrl}/items\`);\n  }\n\n  createData(item: any): Observable&lt;any&gt; {\n    return this.http.post&lt;any&gt;(\`\${this.apiUrl}/items\`, item);\n  }\n  // ... other methods (PUT, DELETE)\n}</code></pre>
                            </li>
                            <li><strong>Consume the Service in a Component:</strong>
                                <pre><code>// my.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({ /* ... */ })\nexport class MyComponent implements OnInit {\n  items: any[] = [];\n\n  constructor(private dataService: DataService) { }\n\n  ngOnInit(): void {\n    this.dataService.getData().subscribe(data => {\n      this.items = data;\n    });\n  }\n}</code></pre>
                            </li>
                         </ol>
                         <p>Best practices include error handling (using <code>catchError</code> from RxJS operators) and using interceptors for tasks like adding authentication tokens.</p>`
            },
            {
                id: 32,
                category: "Data Flow & Communication",
                question: "How do you pass data between components?",
                answer: `<p>There are several ways to pass data between Angular components:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Parent to Child (<code>@Input()</code>):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Parent passes data via property binding. Child receives with <code>@Input()</code>.</li>
                                    <li>Example: <code>&lt;app-child [childData]="parentData"&gt;&lt;/app-child&gt;</code></li>
                                </ul>
                            </li>
                            <li><strong>Child to Parent (<code>@Output()</code> and <code>EventEmitter</code>):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Child emits an event using <code>@Output()</code> and <code>EventEmitter</code>. Parent listens with event binding.</li>
                                    <li>Example: Child: <code>@Output() dataEvent = new EventEmitter&lt;string&gt;(); this.dataEvent.emit('Data');</code> Parent: <code>&lt;app-child (dataEvent)="handleData($event)"&gt;&lt;/app-child&gt;</code></li>
                                </ul>
                            </li>
                            <li><strong>Between Unrelated Components (Services with Observables/Subjects):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>A shared service with an RxJS <code>Subject</code> (e.g., <code>BehaviorSubject</code>) acts as a central data store. Components subscribe to or emit data through the service.</li>
                                </ul>
                            </li>
                            <li><strong>Using <code>ViewChild</code> or <code>ViewChildren</code> (Parent to Child - Direct Access):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Parent gets a direct reference to a child component instance. Allows calling child methods or accessing properties.</li>
                                </ul>
                            </li>
                            <li><strong>Using Route Parameters (for components loaded via Router):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Data is passed as part of the URL. Receiving component uses <code>ActivatedRoute</code> to read parameters.</li>
                                </ul>
                            </li>
                         </ol>`
            },
            {
                id: 33,
                category: "Pipes",
                question: "What are pipes in Angular?",
                answer: `<p>Pipes in Angular are simple classes decorated with <code>@Pipe()</code> that allow you to <strong>transform data directly within your templates</strong> before it is displayed to the user. They are used to format, filter, or manipulate data in a declarative way.</p>
                         <p><strong>Key characteristics:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Pure Functions (by default):</strong> Produce the same output for the same input and have no side effects. Angular executes a pure pipe only when it detects a pure change to the input value or parameters.</li>
                            <li><strong>Chaining:</strong> Multiple pipes can be chained together (<code>{{ value | pipe1 | pipe2 }}</code>).</li>
                            <li><strong>Parameters:</strong> Pipes can accept optional parameters (<code>{{ value | currency:'USD':true }}</code>).</li>
                         </ul>
                         <p><strong>Syntax:</strong> <code>{{ value | pipeName[:param1[:param2]] }}</code></p>`
            },
            {
                id: 34,
                category: "Pipes",
                question: "Can you give examples of inbuilt Angular pipes?",
                answer: `<p>Angular provides several built-in pipes:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>DatePipe</code>:</strong> Formats dates. Example: <code>{{ myDate | date:'short' }}</code></li>
                            <li><strong><code>UpperCasePipe</code>:</strong> Converts text to uppercase. Example: <code>{{ 'hello' | uppercase }}</code></li>
                            <li><strong><code>LowerCasePipe</code>:</strong> Converts text to lowercase. Example: <code>{{ 'HELLO' | lowercase }}</code></li>
                            <li><strong><code>CurrencyPipe</code>:</strong> Formats numbers as currency. Example: <code>{{ 123.45 | currency:'USD' }}</code></li>
                            <li><strong><code>DecimalPipe</code> (or <code>NumberPipe</code>):</strong> Formats numbers as decimals. Example: <code>{{ 3.14159 | number:'1.2-2' }}</code></li>
                            <li><strong><code>PercentPipe</code>:</strong> Formats numbers as percentages. Example: <code>{{ 0.75 | percent }}</code></li>
                            <li><strong><code>JsonPipe</code>:</strong> Converts an object or array to a JSON string (for debugging). Example: <code>{{ myObject | json }}</code></li>
                            <li><strong><code>SlicePipe</code>:</strong> Creates a new Array or String containing a subset of elements. Example: <code>{{ [1,2,3,4,5] | slice:1:3 }}</code></li>
                            <li><strong><code>AsyncPipe</code>:</strong> Subscribes to an Observable or Promise and returns the latest emitted value. Handles unsubscription automatically. Example: <code>{{ myObservable$ | async }}</code></li>
                         </ul>`
            },
            {
                id: 35,
                category: "Pipes",
                question: "How do you write a custom pipe?",
                answer: `<p>To write a custom pipe in Angular:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Create the Pipe Class:</strong> Use Angular CLI (<code>ng generate pipe myPipe</code>) or create a TypeScript file manually.</li>
                            <li><strong>Implement <code>PipeTransform</code> Interface:</strong> The class must implement this interface, which requires a <code>transform()</code> method.</li>
                            <li><strong>Decorate with <code>@Pipe()</code>:</strong> Provide a <code>name</code> property for the pipe (used in templates).</li>
                            <li><strong>Define <code>transform()</code> Method:</strong> This method takes the input value and optional parameters, and returns the transformed value.</li>
                            <li><strong>Declare in an <code>NgModule</code>:</strong> Add the pipe to the <code>declarations</code> array of a module.</li>
                         </ol>
                         <p><strong>Example (a pipe to truncate text):</strong></p>
                         <pre><code>// truncate.pipe.ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'truncate'\n})\nexport class TruncatePipe implements PipeTransform {\n  transform(value: string, limit: number = 20, trail: string = '...'): string {\n    if (!value) return '';\n    return value.length > limit ? value.substring(0, limit) + trail : value;\n  }\n}</code></pre>
                         <p><strong>Usage in template:</strong> <code>{{ longText | truncate:50 }}</code></p>
                         <p><strong>Module Declaration:</strong></p>
                         <pre><code>// app.module.ts\nimport { TruncatePipe } from './truncate.pipe';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    TruncatePipe // Declare here\n  ],\n  // ...\n})\nexport class AppModule { }</code></pre>`
            },
            {
                id: 36,
                category: "RxJS",
                question: "What is RxJs and why is it needed?",
                answer: `<p><strong>RxJS (Reactive Extensions for JavaScript)</strong> is a library for <strong>reactive programming</strong> using <strong>Observables</strong>, to make it easier to compose asynchronous or callback-based code. It provides a powerful way to handle asynchronous data streams and events.</p>
                         <p><strong>Why is it needed (especially in Angular)?</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Handling Asynchronicity:</strong> Manages asynchronous operations (HTTP requests, user events, timers) in a unified way.</li>
                            <li><strong>Declarative Approach:</strong> Describes how data streams should be transformed and handled, leading to cleaner code.</li>
                            <li><strong>Stream Composition:</strong> Rich set of operators to compose, transform, filter, and combine multiple asynchronous streams.</li>
                            <li><strong>Error Handling:</strong> Robust mechanisms for handling errors in streams.</li>
                            <li><strong>Cancellation:</strong> Observables can be easily cancelled (unsubscribed from), preventing memory leaks.</li>
                            <li><strong>Angular's Core:</strong> Angular heavily uses RxJS for <code>HttpClient</code>, <code>Router</code> events, and reactive forms.</li>
                         </ul>`
            },
            {
                id: 37,
                category: "RxJS",
                question: "What are observables and observers?",
                answer: `<p>In RxJS, <strong>Observables</strong> and <strong>Observers</strong> are the two primary participants in the reactive pattern:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Observable:</strong>
                                <ul class="list-circle list-inside ml-6">
                                    <li>A producer of values over time. It's a "stream" that can emit multiple values (data, events, errors, or a completion signal) asynchronously.</li>
                                    <li>It's a **lazy Push system**: It won't start emitting values until an Observer "subscribes" to it.</li>
                                    <li>Example: HTTP requests in Angular (<code>HttpClient</code>) return Observables.</li>
                                </ul>
                            </li>
                            <li><strong>Observer:</strong>
                                <ul class="list-circle list-inside ml-6">
                                    <li>A consumer of values produced by an Observable. It's a set of callback functions.</li>
                                    <li>An Observer typically has three methods:
                                        <ul class="list-disc list-inside ml-8">
                                            <li><code>next(value)</code>: Called for each value emitted.</li>
                                            <li><code>error(err)</code>: Called if the Observable encounters an error.</li>
                                            <li><code>complete()</code>: Called when the Observable finishes emitting values.</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                         </ul>
                         <p><strong>Relationship:</strong> When an Observer <code>subscribes()</code> to an Observable, the Observable begins to execute and deliver values to that Observer's callbacks.</p>`
            },
            {
                id: 38,
                category: "RxJS",
                question: "What is a stream in RxJs?",
                answer: `<p>In RxJS, a <strong>stream</strong> is a sequence of events or data that are emitted over time. It's a core concept of reactive programming, represented by an <strong>Observable</strong>.</p>
                         <p><strong>Analogy:</strong> Think of a stream as a flowing river.</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li>The <strong>river</strong> is the stream (the Observable).</li>
                            <li>The <strong>water molecules</strong> are the values being emitted.</li>
                            <li>The flow can vary (values emitted at different times).</li>
                            <li>You can use RxJS operators (like filters) to transform the stream.</li>
                            <li>An Observer subscribes to "collect" the values.</li>
                         </ul>
                         <p><strong>Characteristics:</strong> Asynchronous, ordered sequence, can be finite or infinite, composable using operators.</p>`
            },
            {
                id: 39,
                category: "RxJS",
                question: "What is the use of subscribe in RxJs?",
                answer: `<p>The <code>subscribe()</code> method in RxJS is fundamental because it's how you <strong>initiate the execution of an Observable</strong> and <strong>start receiving the values it emits</strong>.</p>
                         <p><strong>Key uses of <code>subscribe()</code>:</strong></p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Triggering Observable Execution:</strong> An Observable is "lazy." It won't do anything until an Observer <code>subscribes()</code> to it.</li>
                            <li><strong>Receiving Emitted Values:</strong> The <code>subscribe()</code> method takes up to three callback functions (or an <code>Observer</code> object):
                                <ul class="list-disc list-inside ml-6">
                                    <li><code>next(value)</code>: Executed for each new value.</li>
                                    <li><code>error(err)</code>: Executed if an error occurs.</li>
                                    <li><code>complete()</code>: Executed when the Observable finishes.</li>
                                </ul>
                            </li>
                            <li><strong>Returning a Subscription:</strong> The <code>subscribe()</code> method returns a <code>Subscription</code> object, which is crucial for <strong>unsubscribing</strong> from the stream to prevent memory leaks.</li>
                         </ol>
                         <p><strong>Example:</strong></p>
                         <pre><code>import { of } from 'rxjs';\n\nconst myObservable = of(1, 2, 3);\n\nmyObservable.subscribe({\n  next: value => console.log('Received:', value),\n  error: err => console.error('Error:', err),\n  complete: () => console.log('Observable completed!')\n});</code></pre>`
            },
            {
                id: 40,
                category: "RxJS",
                question: "How do you unsubscribe from a stream?",
                answer: `<p>Unsubscribing from an RxJS stream is crucial for <strong>preventing memory leaks</strong>. You do this by calling the <code>unsubscribe()</code> method on the <code>Subscription</code> object returned by the <code>subscribe()</code> call.</p>
                         <p><strong>Common methods:</strong></p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Manual Unsubscription (using <code>Subscription</code> object):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Store the <code>Subscription</code>.</li>
                                    <li>Call <code>unsubscribe()</code> in the <code>ngOnDestroy()</code> lifecycle hook.</li>
                                </ul>
                                <pre><code>import { Subscription } from 'rxjs';\n// ...\nprivate dataSubscription!: Subscription;\nngOnInit(): void {\n  this.dataSubscription = this.dataService.getData().subscribe(/* ... */);\n}\nngOnDestroy(): void {\n  if (this.dataSubscription) {\n    this.dataSubscription.unsubscribe();\n  }\n}</code></pre>
                            </li>
                            <li><strong>Using <code>AsyncPipe</code> (for template subscriptions):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Angular handles unsubscription automatically when the component is destroyed. Preferred for template-bound observables.</li>
                                    <li>Example: <code>&lt;div *ngIf="myObservable$ | async as data"&gt;{{ data }}&lt;/div&gt;</code></li>
                                </ul>
                            </li>
                            <li><strong>Using RxJS Operators (<code>takeUntil</code>, <code>takeWhile</code>, <code>first</code>, <code>take</code>):</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Declaratively manage when an Observable should complete.</li>
                                    <li><strong><code>takeUntil(notifier$)</code>:</strong> Very common with a <code>Subject</code> in <code>ngOnDestroy</code>.</li>
                                </ul>
                                <pre><code>import { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n// ...\nprivate destroy$ = new Subject&lt;void&gt;();\nngOnInit(): void {\n  this.dataService.getData()\n    .pipe(takeUntil(this.destroy$))\n    .subscribe(/* ... */);\n}\nngOnDestroy(): void {\n  this.destroy$.next();\n  this.destroy$.complete();\n}</code></pre>
                            </li>
                         </ol>
                         <p><strong>When unsubscription is NOT needed:</strong> For Observables that complete naturally (e.g., <code>HttpClient</code> calls, <code>of()</code>) or when using <code>AsyncPipe</code>.</p>`
            },
            {
                id: 41,
                category: "RxJS",
                question: "What are operators in RxJs?",
                answer: `<p>Operators in RxJS are <strong>functions that enable reactive programming by transforming, filtering, combining, or creating Observables</strong>. They are pure functions that return a *new* Observable, allowing for powerful chaining using the <code>.pipe()</code> method.</p>
                         <p><strong>Types of Operators:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Creation Operators:</strong> Create new Observables (e.g., <code>of()</code>, <code>from()</code>, <code>interval()</code>, <code>fromEvent()</code>).</li>
                            <li><strong>Pipeable Operators:</strong> Used with <code>.pipe()</code>.
                                <ul class="list-circle list-inside ml-6">
                                    <li><strong>Transformation:</strong> Change emitted values (e.g., <code>map()</code>, <code>filter()</code>, <code>tap()</code>, <code>debounceTime()</code>, <code>switchMap()</code>, <code>mergeMap()</code>, <code>concatMap()</code>).</li>
                                    <li><strong>Filtering:</strong> Selectively emit values (e.g., <code>filter()</code>, <code>take()</code>, <code>takeUntil()</code>, <code>skip()</code>).</li>
                                    <li><strong>Combination:</strong> Combine multiple Observables (e.g., <code>combineLatest()</code>, <code>forkJoin()</code>, <code>merge()</code>, <code>concat()</code>).</li>
                                    <li><strong>Utility/Error Handling:</strong> (e.g., <code>delay()</code>, <code>retry()</code>, <code>catchError()</code>).</li>
                                </ul>
                            </li>
                         </ul>
                         <p><strong>Example of chaining:</strong></p>
                         <pre><code>import { fromEvent } from 'rxjs';\nimport { debounceTime, map, distinctUntilChanged } from 'rxjs/operators';\n\nfromEvent(searchInput, 'keyup').pipe(\n  map((event: any) => event.target.value),\n  debounceTime(300),\n  distinctUntilChanged()\n).subscribe(value => console.log('Searching for:', value));</code></pre>`
            },
            {
                id: 42,
                category: "RxJS",
                question: "Where have you used RxJs in Angular?",
                answer: `<p>RxJS is deeply integrated into Angular and used in many scenarios:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>HTTP Requests (<code>HttpClient</code>):</strong> Methods like <code>.get()</code>, <code>.post()</code> return Observables. Operators like <code>map</code>, <code>catchError</code> are used.</li>
                            <li><strong>Angular Router:</strong> <code>ActivatedRoute</code> properties (<code>paramMap</code>, <code>queryParamMap</code>) and <code>router.events</code> are Observables.</li>
                            <li><strong>Reactive Forms:</strong> <code>valueChanges</code> and <code>statusChanges</code> on form controls are Observables, useful for real-time validation or dynamic UI.</li>
                            <li><strong>Event Handling:</strong> <code>fromEvent</code> can create Observables from DOM events for complex event streams. <code>@Output() EventEmitter</code> is based on RxJS Subject.</li>
                            <li><strong>State Management:</strong> Building custom state solutions with <code>BehaviorSubject</code> or using libraries like NgRx (built on RxJS).</li>
                            <li><strong>Debouncing User Input:</strong> Using <code>debounceTime</code> for search functionality.</li>
                            <li><strong>Error Handling:</strong> Using <code>catchError</code> for graceful error management.</li>
                            <li><strong>Polling/Intervals:</strong> Using <code>interval</code> for periodic data fetching.</li>
                            <li><strong>Combining Multiple Asynchronous Operations:</strong> Using <code>forkJoin</code>, <code>combineLatest</code>, <code>merge</code>.</li>
                         </ol>`
            },
            {
                id: 43,
                category: "RxJS",
                question: "Differentiate between RxJs and Promises.",
                answer: `<table>
                            <thead>
                                <tr><th>Feature</th><th>RxJS Observables</th><th>Promises</th></tr>
                            </thead>
                            <tbody>
                                <tr><td><strong>Nature</strong></td><td><strong>Stream of values</strong> (can emit 0, 1, or many values over time)</td><td><strong>Single value</strong> (resolves with one value or rejects with one error)</td></tr>
                                <tr><td><strong>Laziness</strong></td><td><strong>Lazy</strong> (execution starts only when subscribed)</td><td><strong>Eager</strong> (execution starts immediately upon creation)</td></tr>
                                <tr><td><strong>Cancellation</strong></td><td><strong>Cancellable</strong> (can <code>unsubscribe()</code>)</td><td><strong>Not cancellable</strong> (once initiated, it runs to completion)</td></tr>
                                <tr><td><strong>Composition</strong></td><td>Rich set of <strong>operators</strong> for powerful transformations, filtering, and combinations.</td><td><code>.then()</code>, <code>.catch()</code>, <code>.finally()</code> for chaining. Less expressive for complex async flows.</td></tr>
                                <tr><td><strong>Error Handling</strong></td><td><code>error</code> callback, <code>catchError</code> operator, can retry.</td><td><code>.catch()</code> for errors. Once rejected, it stays rejected.</td></tr>
                                <tr><td><strong>Completion</strong></td><td>Has a <code>complete()</code> notification.</td><td>No explicit completion notification, implicitly completes on resolve/reject.</td></tr>
                                <tr><td><strong>Synchronous/Asynchronous</strong></td><td>Can be synchronous or asynchronous.</td><td>Always asynchronous.</td></tr>
                                <tr><td><strong>Use Cases</strong></td><td>HTTP requests (multiple responses), real-time events, user input streams, animations.</td><td>Single asynchronous operation (e.g., single HTTP request, file read).</td></tr>
                            </tbody>
                         </table>
                         <p><strong>Summary:</strong> Use Promises for single, one-off async operations. Use Observables for streams of data, multiple events, or when advanced composition and cancellation are needed. Angular heavily favors Observables.</p>`
            },
            {
                id: 44,
                category: "RxJS",
                question: "How do you install RxJs?",
                answer: `<p>RxJS is typically installed automatically when you create a new Angular project using the Angular CLI, as it's a core dependency of Angular.</p>
                         <p>If you need to install it manually or in a non-Angular Node.js/JavaScript project:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li>Open your terminal or command prompt.</li>
                            <li>Navigate to your project's root directory.</li>
                            <li>Run the npm install command:
                                <pre><code>npm install rxjs</code></pre>
                                or using Yarn:
                                <pre><code>yarn add rxjs</code></pre>
                            </li>
                         </ol>
                         <p>This will download RxJS and add it to your <code>node_modules</code> folder and <code>package.json</code>.</p>`
            },
            {
                id: 45,
                category: "RxJS",
                question: "Why is RxJs called push/reactive and not pull/imperative?",
                answer: `<p>This distinction highlights how data is delivered:</p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Pull System (Imperative):</strong>
                                <ul class="list-circle list-inside ml-6">
                                    <li>The <strong>consumer</strong> explicitly requests data from the producer.</li>
                                    <li>Examples: Functions (you "pull" the return value), Iterators (you call <code>next()</code>).</li>
                                    <li>The consumer controls the pace.</li>
                                </ul>
                            </li>
                            <li><strong>Push System (Reactive - RxJS Observables):</strong>
                                <ul class="list-circle list-inside ml-6">
                                    <li>The <strong>producer</strong> sends data to the consumer when data becomes available. The consumer *reacts* to what's pushed.</li>
                                    <li>Examples: Promises (push a single value/error), RxJS Observables (push multiple values over time).</li>
                                    <li>The producer controls the pace.</li>
                                </ul>
                            </li>
                         </ul>
                         <p><strong>Why RxJS is Push/Reactive:</strong> Observables are push systems because they don't emit values until subscribed, and then the Observable (producer) pushes values to the Observer (consumer) as they become available. This model is ideal for handling asynchronous events and data streams.</p>`
            },
            {
                id: 46,
                category: "RxJS",
                question: "Name some RxJs operators.",
                answer: `<p>Here are some commonly used RxJS operators:</p>
                         <p><strong>Creation Operators:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><code>of()</code>, <code>from()</code>, <code>interval()</code>, <code>fromEvent()</code>, <code>ajax()</code></li>
                         </ul>
                         <p><strong>Pipeable Operators:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Transformation:</strong> <code>map()</code>, <code>pluck()</code>, <code>scan()</code>, <code>mergeMap()</code> (or <code>flatMap()</code>), <code>switchMap()</code>, <code>concatMap()</code></li>
                            <li><strong>Filtering:</strong> <code>filter()</code>, <code>take()</code>, <code>takeUntil()</code>, <code>debounceTime()</code>, <code>distinctUntilChanged()</code>, <code>skip()</code></li>
                            <li><strong>Combination:</strong> <code>combineLatest()</code>, <code>forkJoin()</code>, <code>merge()</code>, <code>zip()</code>, <code>concat()</code></li>
                            <li><strong>Utility/Error Handling:</strong> <code>tap()</code>, <code>catchError()</code>, <code>retry()</code>, <code>delay()</code></li>
                         </ul>`
            },
            {
                id: 47,
                category: "HTTP & Services",
                question: "What are interceptors in Angular?",
                answer: `<p><strong>Interceptors</strong> in Angular are a powerful feature that allows you to <strong>intercept and modify HTTP requests and responses</strong> before they are sent to the server or processed by your application. They are part of the <code>HttpClientModule</code>.</p>
                         <p>Think of them as middleware for your HTTP communication, sitting between your <code>HttpClient</code> calls and the backend.</p>
                         <p><strong>Key characteristics:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong><code>HttpInterceptor</code> Interface:</strong> Interceptors implement this interface, requiring an <code>intercept()</code> method.</li>
                            <li><strong><code>HttpRequest</code> and <code>HttpHandler</code>:</strong> The <code>intercept()</code> method receives the outgoing <code>HttpRequest</code> and an <code>HttpHandler</code> (to pass the request to the next interceptor or backend).</li>
                            <li><strong>Chainable:</strong> You can have multiple interceptors forming a chain.</li>
                            <li><strong>Immutable Requests:</strong> Requests are immutable; clone them to modify.</li>
                         </ul>`
            },
            {
                id: 48,
                category: "HTTP & Services",
                question: "How do you implement interceptors?",
                answer: `<p>Implementing an HTTP Interceptor in Angular involves three main steps:</p>
                         <ol class="list-decimal list-inside ml-4 space-y-1">
                            <li><strong>Create the Interceptor Class:</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Create a TypeScript class implementing <code>HttpInterceptor</code>.</li>
                                    <li>Implement the <code>intercept()</code> method.</li>
                                </ul>
                                <pre><code>// auth.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  intercept(request: HttpRequest&lt;unknown&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {\n    const authToken = localStorage.getItem('token');\n    if (authToken) {\n      const authRequest = request.clone({\n        headers: request.headers.set('Authorization', \`Bearer \${authToken}\`)\n      });\n      return next.handle(authRequest);\n    }\n    return next.handle(request);\n  }\n}</code></pre>
                            </li>
                            <li><strong>Provide the Interceptor:</strong>
                                <ul class="list-disc list-inside ml-6">
                                    <li>Register in the <code>providers</code> array of your <code>AppModule</code>.</li>
                                    <li>Use the <code>HTTP_INTERCEPTORS</code> injection token and set <code>multi: true</code>.</li>
                                </ul>
                                <pre><code>// app.module.ts\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { AuthInterceptor } from './auth.interceptor';\n\n@NgModule({\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: AuthInterceptor,\n      multi: true\n    }\n  ],\n  // ...\n})\nexport class AppModule { }</code></pre>
                            </li>
                            <li><strong>Order of Execution:</strong> Interceptors run in the order they are provided.</li>
                         </ol>`
            },
            {
                id: 49,
                category: "HTTP & Services",
                question: "What are some uses of interceptors, and can we provide multi-interceptors?",
                answer: `<p><strong>Uses of Interceptors:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Authentication/Authorization:</strong> Adding tokens, redirecting on 401.</li>
                            <li><strong>Error Handling:</strong> Centralized error display, logging.</li>
                            <li><strong>Loading Indicators:</strong> Global spinners.</li>
                            <li><strong>Caching:</strong> Client-side HTTP caching.</li>
                            <li><strong>Logging:</strong> Request/response logging.</li>
                            <li><strong>URL Transformation:</strong> Adding base API URLs.</li>
                            <li><strong>Request/Response Transformation:</strong> Modifying bodies.</li>
                            <li><strong>Headers Management:</strong> Adding common headers.</li>
                         </ul>
                         <p><strong>Can we provide multi-interceptors?</strong></p>
                         <p><strong>Yes, absolutely!</strong> Angular supports multiple interceptors. Provide them in the <code>providers</code> array with <code>multi: true</code> for each.</p>
                         <pre><code>providers: [\n  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n  { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true },\n  { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }\n]</code></pre>
                         <p>They form a chain, executing in the order provided for outgoing requests and in reverse order for incoming responses. Each calls <code>next.handle()</code> to pass control.</p>`
            },
            { // Question 50 was missing, adding it here based on the intro.
                id: 50,
                category: "HTTP & Services",
                question: "What are some uses of interceptors, and can we provide multi-interceptors? (Duplicate of 49, assuming it meant to be a different question or a typo in the source list. I will provide the same answer as 49 as the question is identical)",
                answer: `<p><strong>Uses of Interceptors:</strong></p>
                         <ul class="list-disc list-inside ml-4 space-y-1">
                            <li><strong>Authentication/Authorization:</strong> Adding tokens, redirecting on 401.</li>
                            <li><strong>Error Handling:</strong> Centralized error display, logging.</li>
                            <li><strong>Loading Indicators:</strong> Global spinners.</li>
                            <li><strong>Caching:</strong> Client-side HTTP caching.</li>
                            <li><strong>Logging:</strong> Request/response logging.</li>
                            <li><strong>URL Transformation:</strong> Adding base API URLs.</li>
                            <li><strong>Request/Response Transformation:</strong> Modifying bodies.</li>
                            <li><strong>Headers Management:</strong> Adding common headers.</li>
                         </ul>
                         <p><strong>Can we provide multi-interceptors?</strong></p>
                         <p><strong>Yes, absolutely!</strong> Angular supports multiple interceptors. Provide them in the <code>providers</code> array with <code>multi: true</code> for each.</p>
                         <pre><code>providers: [\n  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n  { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true },\n  { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }\n]</code></pre>
                         <p>They form a chain, executing in the order provided for outgoing requests and in reverse order for incoming responses. Each calls <code>next.handle()</code> to pass control.</p>`
            }
        ];

        const questionListEl = document.getElementById('questionList');
        const categoryButtonsEl = document.getElementById('categoryButtons');
        const searchInputEl = document.getElementById('searchInput');
        const selectedQuestionEl = document.getElementById('selectedQuestion');
        const selectedAnswerEl = document.getElementById('selectedAnswer');
        const qaDisplayEl = document.getElementById('qaDisplay');
        const welcomeMessageEl = document.getElementById('welcomeMessage');

        let currentQuestions = [...interviewQuestions];
        let activeCategory = 'All';
        let activeQuestionId = null;

        function getCategories() {
            const categories = new Set(interviewQuestions.map(q => q.category));
            return ['All', ...Array.from(categories).sort()];
        }

        function renderCategories() {
            const categories = getCategories();
            categoryButtonsEl.innerHTML = categories.map(category => `
                <button
                    class="category-button px-3 py-1.5 text-sm font-medium rounded-md border border-slate-300 hover:bg-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-500 ${category === activeCategory ? 'active-category' : 'bg-white text-slate-700'}"
                    data-category="${category}"
                >
                    ${category}
                </button>
            `).join('');

            document.querySelectorAll('.category-button').forEach(button => {
                button.addEventListener('click', () => {
                    activeCategory = button.dataset.category;
                    filterAndRenderQuestions();
                    updateActiveCategoryButton();
                });
            });
        }

        function updateActiveCategoryButton() {
            document.querySelectorAll('.category-button').forEach(button => {
                if (button.dataset.category === activeCategory) {
                    button.classList.add('active-category');
                    button.classList.remove('bg-white', 'text-slate-700');
                } else {
                    button.classList.remove('active-category');
                    button.classList.add('bg-white', 'text-slate-700');
                }
            });
        }

        function renderQuestions(questionsToRender) {
            questionListEl.innerHTML = questionsToRender.map(q => `
                <li
                    class="question-item p-2.5 rounded-md cursor-pointer hover:bg-slate-200 transition-colors duration-150 ${q.id === activeQuestionId ? 'active-question' : 'text-slate-700'}"
                    data-id="${q.id}"
                >
                    <span class="font-medium text-sm">${q.id}. ${q.question}</span>
                </li>
            `).join('');

            document.querySelectorAll('.question-item').forEach(item => {
                item.addEventListener('click', () => {
                    const questionId = parseInt(item.dataset.id);
                    displayQuestionAndAnswer(questionId);
                });
            });
        }

        function displayQuestionAndAnswer(id) {
            const question = interviewQuestions.find(q => q.id === id);
            if (question) {
                activeQuestionId = id;
                selectedQuestionEl.textContent = `${question.id}. ${question.question}`;
                selectedAnswerEl.innerHTML = question.answer;
                qaDisplayEl.classList.remove('hidden');
                welcomeMessageEl.classList.add('hidden');
                updateActiveQuestionItem();
                 // Scroll main content to top
                document.getElementById('mainContent').scrollTop = 0;
            }
        }

        function updateActiveQuestionItem() {
            document.querySelectorAll('.question-item').forEach(item => {
                if (parseInt(item.dataset.id) === activeQuestionId) {
                    item.classList.add('active-question');
                    item.classList.remove('text-slate-700');
                } else {
                    item.classList.remove('active-question');
                    item.classList.add('text-slate-700');
                }
            });
        }


        function filterAndRenderQuestions() {
            const searchTerm = searchInputEl.value.toLowerCase();
            let filteredQuestions = interviewQuestions;

            if (activeCategory !== 'All') {
                filteredQuestions = filteredQuestions.filter(q => q.category === activeCategory);
            }

            if (searchTerm) {
                filteredQuestions = filteredQuestions.filter(q =>
                    q.question.toLowerCase().includes(searchTerm) ||
                    q.answer.toLowerCase().includes(searchTerm) ||
                    q.category.toLowerCase().includes(searchTerm)
                );
            }
            currentQuestions = filteredQuestions;
            renderQuestions(currentQuestions);
            updateActiveQuestionItem(); // Ensure selection highlight is maintained after filtering
        }

        searchInputEl.addEventListener('input', filterAndRenderQuestions);

        // Initial render
        renderCategories();
        renderQuestions(currentQuestions);

    </script>
    </body>
</html>
